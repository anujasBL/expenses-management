# Cursor Rules for Expenses Management System
# Technology Stack: React + TypeScript + Tailwind CSS + shadcn/ui

## Project Overview
You are developing an expenses management system for a 4-hour hackathon. Focus on rapid development, clean code, and functional MVP delivery.

## Technology Stack Requirements
- **Frontend**: React 18.2+, TypeScript 5.0+
- **Styling**: Tailwind CSS 3.3+, shadcn/ui components
- **Form Handling**: React Hook Form 7.45+, Zod 3.22+
- **State Management**: React Query 5.0+ (for patterns), localStorage
- **Charts**: Recharts 2.8+
- **Icons**: Lucide React 0.263+
- **Build Tool**: Vite 5.0+

## Code Style & Standards

### TypeScript
- Use strict TypeScript configuration
- Define explicit interfaces for all data models
- Use type inference where appropriate, but be explicit for complex types
- Prefer `interface` over `type` for object shapes
- Use union types for discriminated unions
- Implement proper error handling with typed errors

### React Patterns
- Use functional components with hooks
- Prefer `useState` and `useEffect` for local state
- Use `useMemo` and `useCallback` for performance optimization
- Implement proper dependency arrays in hooks
- Use React.memo for expensive components
- Follow React 18+ patterns and best practices

### Component Structure
- One component per file
- Use PascalCase for component names
- Export components as named exports
- Keep components focused and single-responsibility
- Use composition over inheritance
- Implement proper prop validation with TypeScript

## File Organization

### Project Structure
```
src/
├── components/
│   ├── ui/           # shadcn/ui components
│   ├── forms/        # Form components
│   ├── layout/       # Layout components
│   └── charts/       # Chart components
├── hooks/            # Custom React hooks
├── lib/              # Utility functions
├── types/            # TypeScript interfaces
├── utils/            # Helper functions
└── services/         # Data and API services
```

### Naming Conventions
- **Components**: PascalCase (e.g., `ExpenseForm.tsx`)
- **Hooks**: camelCase with 'use' prefix (e.g., `useExpenses.ts`)
- **Types**: PascalCase (e.g., `Expense.ts`)
- **Utilities**: camelCase (e.g., `formatCurrency.ts`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `EXPENSE_CATEGORIES`)

## Component Guidelines

### Form Components
- Use React Hook Form for all forms
- Implement Zod validation schemas
- Use shadcn/ui form components
- Provide clear error messages and validation feedback
- Implement proper accessibility (aria-labels, error associations)

### UI Components
- Use shadcn/ui components as the foundation
- Extend with Tailwind CSS for custom styling
- Maintain consistent spacing using Tailwind's spacing scale
- Use semantic HTML elements
- Implement responsive design with mobile-first approach

### Data Components
- Implement proper loading states
- Handle empty states gracefully
- Use optimistic updates where appropriate
- Implement proper error boundaries
- Use React Query patterns for data fetching (even with localStorage)

## Styling Guidelines

### Tailwind CSS
- Use utility-first approach
- Prefer Tailwind classes over custom CSS
- Use responsive prefixes (sm:, md:, lg:, xl:)
- Implement dark mode support where appropriate
- Use consistent color palette from shadcn/ui

### Responsive Design
- Mobile-first approach
- Use Tailwind breakpoints consistently
- Implement touch-friendly interactions
- Ensure proper spacing on all devices
- Test on multiple screen sizes

## State Management

### Local State
- Use `useState` for component-level state
- Use `useReducer` for complex state logic
- Implement proper state updates with immutability
- Use `useCallback` for state update functions passed to children

### Persistent State
- Use localStorage for data persistence
- Implement proper error handling for storage operations
- Use IndexedDB as fallback for larger datasets
- Implement data validation before storage

### Form State
- Use React Hook Form for all form state
- Implement proper form validation with Zod
- Use controlled components where necessary
- Implement proper form submission handling

## Data Models & Types

### Core Interfaces
```typescript
interface Expense {
  id: string;
  amount: number;
  description: string;
  category: ExpenseCategory;
  date: Date;
  createdAt: Date;
  updatedAt: Date;
}

interface ExpenseCategory {
  id: string;
  name: string;
  color: string;
  icon: string;
  description?: string;
}

interface ExpenseFormData {
  amount: number;
  description: string;
  category: string;
  date: Date;
}
```

### Validation Schemas
- Use Zod for all data validation
- Implement comprehensive validation rules
- Provide clear error messages
- Use proper TypeScript inference from schemas

## Performance Guidelines

### Optimization Techniques
- Use `React.memo` for expensive components
- Implement `useMemo` for expensive calculations
- Use `useCallback` for function props
- Implement proper dependency arrays
- Use React DevTools Profiler for performance analysis

### Bundle Optimization
- Implement code splitting where appropriate
- Use dynamic imports for heavy components
- Optimize images and assets
- Implement proper tree shaking

## Error Handling

### Form Validation
- Implement real-time validation
- Provide clear error messages
- Use proper error states and styling
- Implement field-level error handling

### Runtime Errors
- Use error boundaries for component errors
- Implement proper error logging
- Provide user-friendly error messages
- Implement graceful degradation

### Storage Errors
- Handle localStorage quota exceeded
- Implement fallback storage strategies
- Provide data backup/restore functionality
- Implement proper error recovery

## Accessibility

### Standards
- Follow WCAG 2.1 AA guidelines
- Implement proper ARIA labels
- Use semantic HTML elements
- Ensure keyboard navigation
- Implement proper focus management

### Form Accessibility
- Associate labels with form controls
- Provide proper error announcements
- Implement proper validation feedback
- Use appropriate input types

## Testing Considerations

### Component Testing
- Write testable components
- Use proper prop interfaces
- Implement proper error handling
- Use consistent component APIs

### Data Testing
- Implement proper data validation
- Test edge cases and error conditions
- Use proper TypeScript types for testing
- Implement proper mock data

## Development Workflow

### Code Quality
- Use ESLint for code linting
- Use Prettier for code formatting
- Implement proper TypeScript strict mode
- Use proper import/export patterns

### Git Workflow
- Use conventional commit messages
- Implement proper branching strategy
- Use proper PR templates
- Implement proper code review process

## Specific Implementation Rules

### Expense Management
- Implement CRUD operations for expenses
- Use proper data validation
- Implement proper error handling
- Use optimistic updates where appropriate

### Category System
- Use predefined expense categories
- Implement proper color and icon mapping
- Use consistent visual representation
- Implement proper category validation

### Analytics & Charts
- Use Recharts for data visualization
- Implement proper chart responsiveness
- Use consistent color schemes
- Implement proper data formatting

### Data Persistence
- Use localStorage for primary storage
- Implement proper data serialization
- Use proper error handling
- Implement data backup/restore

## Code Generation Preferences

### When Generating Components
- Always include proper TypeScript interfaces
- Implement proper error handling
- Use shadcn/ui components where appropriate
- Include proper accessibility attributes
- Use consistent naming conventions

### When Generating Hooks
- Include proper TypeScript types
- Implement proper error handling
- Use proper dependency arrays
- Include proper JSDoc comments

### When Generating Utilities
- Include proper TypeScript types
- Implement proper error handling
- Use consistent naming conventions
- Include proper JSDoc comments

## Hackathon Constraints

### Time Management
- Focus on MVP functionality over perfect implementation
- Use existing libraries and components
- Implement basic error handling
- Focus on user experience over edge cases

### Quality vs Speed
- Prioritize working functionality
- Use proven patterns and libraries
- Implement basic testing
- Focus on deployment readiness

## Deployment Considerations

### Build Optimization
- Use Vite for fast builds
- Implement proper environment configuration
- Use proper build scripts
- Implement proper asset optimization

### Hosting
- Prepare for Vercel/Netlify deployment
- Implement proper environment variables
- Use proper build commands
- Implement proper deployment scripts

## Final Notes

Remember that this is a hackathon project with a 4-hour time constraint. Focus on:
1. **Working functionality** over perfect code
2. **User experience** over edge case handling
3. **Deployment readiness** over extensive testing
4. **MVP delivery** over feature completeness

Use this rules file to guide code generation and ensure consistency across the project. When in doubt, prioritize simplicity and functionality over complexity and perfection.
